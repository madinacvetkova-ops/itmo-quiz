<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–ò–Ω–∂–µ–Ω–µ—Ä –ö–¢–£ ‚Äî –ò–¢–ú–û</title>

<style>
:root { --itmo-blue:#0039A6; }

body {
  margin:0;
  font-family:Arial,sans-serif;
  background:#fff;
  color:#000;
}

.wrapper {
  max-width:1200px;
  margin:auto;
  text-align:center;
}

.screen { display:none; padding:20px; }
.screen.active { display:block; }

h1,h2 { color:var(--itmo-blue); }

button {
  padding:12px 18px;
  margin:6px;
  border:2px solid var(--itmo-blue);
  background:#fff;
  color:var(--itmo-blue);
  font-size:15px;
}

button:active {
  background:var(--itmo-blue);
  color:#fff;
}

canvas {
  border:1px solid #aaa;
  margin:10px auto;
  display:block;
  touch-action:manipulation;
}

small { color:#555; }
</style>
</head>

<body>
<div class="wrapper">

<!-- START -->
<div class="screen active">
<h1>–¢—ã ‚Äî –∏–Ω–∂–µ–Ω–µ—Ä –ö–¢–£?</h1>
<p><b>–ú–µ–≥–∞—Ñ–∞–∫—É–ª—å—Ç–µ—Ç –ö–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã—Ö —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</b><br>
–§–∞–∫—É–ª—å—Ç–µ—Ç —Å–∏—Å—Ç–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∏</p>
<button onclick="next()">–ù–∞—á–∞—Ç—å</button>
</div>

<!-- BASIC -->
<div class="screen">
<h2>ü§ñ –ò–ò –∏–ª–∏ —á–µ–ª–æ–≤–µ–∫?</h2>
<p>¬´–ê–ª–≥–æ—Ä–∏—Ç–º –¥—É–º–∞–µ—Ç –±—ã—Å—Ç—Ä–µ–µ, –Ω–æ –Ω–µ –ø–æ–Ω–∏–º–∞–µ—Ç —Å–º—ã—Å–ª¬ª</p>
<button onclick="next()">–ò–ò</button>
<button onclick="next()">–ß–µ–ª–æ–≤–µ–∫</button>
</div>

<div class="screen">
<h2>‚öôÔ∏è –õ–æ–≥–∏–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</h2>
<p>–ï—Å–ª–∏ –¥–∞—Ç—á–∏–∫ —É–≤–∏–¥–µ–ª –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ, —á—Ç–æ –¥–µ–ª–∞–µ—Ç —Ä–æ–±–æ—Ç?</p>
<button onclick="next()">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è</button>
<button onclick="next()">–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—É—Ç—å</button>
</div>

<div class="screen">
<h2>üéì BASIC –ø—Ä–æ–π–¥–µ–Ω</h2>
<p>–ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Ä–µ–∞–ª—å–Ω—ã–º –∏–Ω–∂–µ–Ω–µ—Ä–Ω—ã–º –∑–∞–¥–∞—á–∞–º</p>
<button onclick="next()">üî• Advanced</button>
</div>

<!-- ADVANCED PATH -->
<div class="screen">
<h2>üß≠ –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –ø—É—Ç—å —Ä–æ–±–æ—Ç–∞</h2>
<p>
–¢–∞–ø–∞–π –ø–æ –∫–ª–µ—Ç–∫–∞–º, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —Å—Ç–µ–Ω—ã.<br>
<small>–°–∏–Ω–∏–π ‚Äî –ø–æ–∏—Å–∫, –∑–µ–ª—ë–Ω—ã–π ‚Äî –º–∞—Ä—à—Ä—É—Ç</small>
</p>

<canvas id="grid" width="360" height="360"></canvas>

<button onclick="runBFS()">BFS</button>
<button onclick="runAStar()">A*</button>
<button onclick="resetGrid()">–û—á–∏—Å—Ç–∏—Ç—å</button>
<button onclick="next()">–î–∞–ª–µ–µ</button>
</div>

<!-- FINAL -->
<div class="screen">
<h1>üéì –¢—ã ‚Äî —Å—Ç—É–¥–µ–Ω—Ç –ö–¢–£</h1>
<p>
–¢—ã –ø–æ–ø—Ä–æ–±–æ–≤–∞–ª –∑–∞–¥–∞—á–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤, —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∏.<br>
–¢–∞–∫ —É—á–∞—Ç—Å—è –∏–Ω–∂–µ–Ω–µ—Ä—ã –≤ –ò–¢–ú–û.
</p>
</div>

</div>

<script>
/* ===== SCREEN NAV ===== */
let step=0;
const screens=document.querySelectorAll(".screen");
function next(){
  screens[step].classList.remove("active");
  step++;
  screens[step].classList.add("active");
}

/* ===== GRID SETUP ===== */
const canvas=document.getElementById("grid");
const g=canvas.getContext("2d");
const size=8, cell=45;

const start={x:0,y:7};
const goal={x:7,y:0};
let walls=[];

function isWall(x,y){
  return walls.some(w=>w.x===x&&w.y===y);
}

function drawGrid(visited=[], path=[]){
  g.clearRect(0,0,360,360);

  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      g.strokeRect(x*cell,y*cell,cell,cell);
      if(isWall(x,y)){
        g.fillStyle="#333";
        g.fillRect(x*cell,y*cell,cell,cell);
      }
    }
  }

  visited.forEach(p=>{
    g.fillStyle="rgba(0,120,255,0.4)";
    g.fillRect(p.x*cell,p.y*cell,cell,cell);
  });

  path.forEach(p=>{
    g.fillStyle="rgba(0,180,0,0.6)";
    g.fillRect(p.x*cell,p.y*cell,cell,cell);
  });

  g.fillStyle="green";
  g.fillRect(start.x*cell,start.y*cell,cell,cell);

  g.fillStyle="red";
  g.fillRect(goal.x*cell,goal.y*cell,cell,cell);
}

drawGrid();

/* ===== CLICK TOGGLE WALL ===== */
canvas.addEventListener("click",e=>{
  const rect=canvas.getBoundingClientRect();
  const x=Math.floor((e.clientX-rect.left)/cell);
  const y=Math.floor((e.clientY-rect.top)/cell);

  if((x===start.x&&y===start.y)||(x===goal.x&&y===goal.y)) return;

  const i=walls.findIndex(w=>w.x===x&&w.y===y);
  if(i>=0) walls.splice(i,1);
  else walls.push({x,y});

  drawGrid();
});

/* ===== PATHFINDING ===== */
function neighbors(p){
  return [[1,0],[-1,0],[0,1],[0,-1]]
    .map(d=>({x:p.x+d[0],y:p.y+d[1]}))
    .filter(n=>n.x>=0&&n.y>=0&&n.x<size&&n.y<size&&!isWall(n.x,n.y));
}

function reconstruct(parent){
  let cur=goal, path=[];
  while(cur){
    path.push(cur);
    cur=parent[cur.x+","+cur.y];
  }
  return path;
}

function runBFS(){
  let q=[start], visited=[], seen={}, parent={};
  seen[start.x+","+start.y]=true;

  let t=setInterval(()=>{
    if(!q.length){clearInterval(t);return;}
    let v=q.shift();
    visited.push(v);
    drawGrid(visited);

    if(v.x===goal.x&&v.y===goal.y){
      clearInterval(t);
      drawGrid(visited,reconstruct(parent));
      return;
    }

    neighbors(v).forEach(n=>{
      let k=n.x+","+n.y;
      if(!seen[k]){
        seen[k]=true;
        parent[k]=v;
        q.push(n);
      }
    });
  },100);
}

function runAStar(){
  let open=[start], visited=[], seen={}, parent={};
  seen[start.x+","+start.y]=true;

  let t=setInterval(()=>{
    if(!open.length){clearInterval(t);return;}
    open.sort((a,b)=>
      (Math.abs(a.x-goal.x)+Math.abs(a.y-goal.y))-
      (Math.abs(b.x-goal.x)+Math.abs(b.y-goal.y))
    );

    let v=open.shift();
    visited.push(v);
    drawGrid(visited);

    if(v.x===goal.x&&v.y===goal.y){
      clearInterval(t);
      drawGrid(visited,reconstruct(parent));
      return;
    }

    neighbors(v).forEach(n=>{
      let k=n.x+","+n.y;
      if(!seen[k]){
        seen[k]=true;
        parent[k]=v;
        open.push(n);
      }
    });
  },100);
}

function resetGrid(){
  walls=[];
  drawGrid();
}
</script>

</body>
</html>
